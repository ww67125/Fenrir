
## 全局锁

数据库实例加锁，运行`Flush tables with read lock`命令加全局锁，会让整库处于只读状态。
此时数据的增删改，ddl语句和更新类事务的提交语句会被阻塞。

###### 应用场景

全库逻辑备份，将整个表select导出sql语句。操作危险不推荐使用，只有myisam使用。
推荐使用`mysqldump -single-transaction`参数备份整库。（前提数据库中都是使用事务引擎的表）

## 表级锁

###### 表锁

使用 `lock tables t1 read/write`锁表 可以使用`unlock tables` 主动释放，与客户端断开连接也会自动释放。（不推荐）

###### MDL锁（metedata lock） 元数据锁

不需要显示使用。

###### 增删改查加MDL读锁

读锁之间不互斥，可以多个线程同时增删改查同一表。但是无法做ddl操作
事务结束才会释放MDL写锁

###### 表结构变更操作加MDL写锁

读写锁间，写锁间互斥，同时只能一个线程操作表

## 行级锁

###### 两阶段锁协议
innodb事务中，行锁在需要时加上，事务结束才会释放，
**事务中需要锁多行时,要把最可能造成锁冲突、可能影响并发度的锁往后放。**

## 死锁
不同事务互相等待对方的资源释放
例：事务A获得锁1 事务B获得锁2 都未提交 事务A又去操作锁2行 事务B又去操作锁1行,导致死锁状态

###### 死锁策略
1. 进入等待，直到超时，超时参数innodb_lock_wait_timeout默认50s（InnoDB）
2. 发起死锁检测，发现死锁，主动回滚死锁中的某一个事务,设置参数innodb_deadlock_detect=on 开启(默认开启，死锁检测只有行上有锁再要加锁访问的时候检测)
**(死锁检测会增加额外负担，多个事务更新同一行，死锁检测要执行n*n次，消耗大量cpu资源，执行事务效率低下。 解决方案：关闭死锁检测、控制并发、业务逻辑优化)**
